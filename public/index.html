<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fog of War VTT</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Configuration Constants
    const CONFIG = {
      TOKEN: {
        RADIUS: 12,
        SHADOW_OFFSET: 2,
        HIGHLIGHT_OFFSET: 3,
        HIGHLIGHT_RADIUS: 4,
      },
      CANVAS: {
        BLUR_AMOUNT: 20,
        BACKGROUND_COLOR: '#2a2a2a',
        DARKNESS_OPACITY: 0.90,
      },
      MOVEMENT: {
        STEP: 0.02,
        TOUCH_DELAY_MS: 100,
        UPDATE_DEBOUNCE_MS: 50,
      },
      DEFAULTS: {
        START_POS: { x: 0.85, y: 0.85 },
        REVEAL_RADIUS_PERCENT: 8,
        ZOOM: 1,
      },
      VISION: {
        GRADIENT_INNER_STOP: 0,
        GRADIENT_MID_STOP: 0.75,
        GRADIENT_OUTER_STOP: 1,
        GRADIENT_INNER_ALPHA: 1,
        GRADIENT_MID_ALPHA: 0.9,
        GRADIENT_OUTER_ALPHA: 0,
      },
      COLORS: {
        TOKEN_FILL: '#3b82f6',
        TOKEN_STROKE: '#1e40af',
        TOKEN_SHADOW: 'rgba(0, 0, 0, 0.3)',
        TOKEN_HIGHLIGHT: 'rgba(255, 255, 255, 0.5)',
        GM_HALO: { r: 59, g: 130, b: 246 },
        TORCH_HALO: { r: 255, g: 255, b: 150 },
        TORCH_HALO_OUTER: { r: 255, g: 255, b: 0 },
      }
    };

    function App() {
      const canvasRef = useRef(null);
      const blurCanvasRef = useRef(null);
      const wsRef = useRef(null);
      const [mapImage, setMapImage] = useState(null);
      const [tokenPos, setTokenPos] = useState(CONFIG.DEFAULTS.START_POS);
      const [revealRadiusPercent, setRevealRadiusPercent] = useState(CONFIG.DEFAULTS.REVEAL_RADIUS_PERCENT);
      const [exploredAreas, setExploredAreas] = useState([]);
      const [zoom, setZoom] = useState(CONFIG.DEFAULTS.ZOOM);
      const [isPanning, setIsPanning] = useState(false);
      const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
      const [panStart, setPanStart] = useState({ x: 0, y: 0 });
      const [gmMode, setGmMode] = useState(false);
      const [connected, setConnected] = useState(false);
      const [isGM, setIsGM] = useState(false);
      const [isTouchDevice, setIsTouchDevice] = useState(false);
      const isReceivingUpdate = useRef(false);
      const [gmTorchlight, setGmTorchlight] = useState(false);

      const isDraggingToken = useRef(false);
      const dragStartOffset = useRef({ x: 0, y: 0 });
      const [isDragging, setIsDragging] = useState(false);

      // Canvas Rendering Functions
      const calculateCanvasLayout = (canvas, mapImage, zoom, panOffset) => {
        const scale = Math.min(canvas.width / mapImage.width, canvas.height / mapImage.height) * zoom;
        const scaledWidth = mapImage.width * scale;
        const scaledHeight = mapImage.height * scale;
        const offsetX = (canvas.width - scaledWidth) / 2 + panOffset.x;
        const offsetY = (canvas.height - scaledHeight) / 2 + panOffset.y;
        
        return { scale, scaledWidth, scaledHeight, offsetX, offsetY };
      };

      const drawClearMap = (ctx, canvas, mapImage, layout) => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = CONFIG.CANVAS.BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(mapImage, layout.offsetX, layout.offsetY, layout.scaledWidth, layout.scaledHeight);
      };

      const drawVisionCircle = (ctx, x, y, radius) => {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(CONFIG.VISION.GRADIENT_INNER_STOP, `rgba(255, 255, 255, ${CONFIG.VISION.GRADIENT_INNER_ALPHA})`);
        gradient.addColorStop(CONFIG.VISION.GRADIENT_MID_STOP, `rgba(255, 255, 255, ${CONFIG.VISION.GRADIENT_MID_ALPHA})`);
        gradient.addColorStop(CONFIG.VISION.GRADIENT_OUTER_STOP, `rgba(255, 255, 255, ${CONFIG.VISION.GRADIENT_OUTER_ALPHA})`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      };

      const drawFogOfWar = (blurCtx, canvas, mapImage, layout, exploredAreas, tokenPos, revealRadiusPercent, gmTorchlight) => {
        blurCtx.clearRect(0, 0, canvas.width, canvas.height);
        blurCtx.fillStyle = CONFIG.CANVAS.BACKGROUND_COLOR;
        blurCtx.fillRect(0, 0, canvas.width, canvas.height);
        blurCtx.filter = `blur(${CONFIG.CANVAS.BLUR_AMOUNT}px)`;
        blurCtx.drawImage(mapImage, layout.offsetX, layout.offsetY, layout.scaledWidth, layout.scaledHeight);
        blurCtx.filter = 'none';

        // Darken if torchlight mode
        if (gmTorchlight) {
          blurCtx.fillStyle = `rgba(0, 0, 0, ${CONFIG.CANVAS.DARKNESS_OPACITY})`;
          blurCtx.fillRect(0, 0, canvas.width, canvas.height);
        }

        blurCtx.globalCompositeOperation = 'destination-out';
        
        const visionRadiusInMapUnits = revealRadiusPercent / 100;
        const radius = visionRadiusInMapUnits * layout.scaledWidth;
        
        if (gmTorchlight) {
          // Torchlight mode: only reveal current position
          const x = layout.offsetX + tokenPos.x * layout.scaledWidth;
          const y = layout.offsetY + tokenPos.y * layout.scaledHeight;
          drawVisionCircle(blurCtx, x, y, radius);
        } else {
          // Normal mode: reveal all explored areas
          exploredAreas.forEach(area => {
            const x = layout.offsetX + area.x * layout.scaledWidth;
            const y = layout.offsetY + area.y * layout.scaledHeight;
            drawVisionCircle(blurCtx, x, y, radius);
          });
        }

        blurCtx.globalCompositeOperation = 'source-over';
      };

      const drawToken = (ctx, tokenPos, layout, revealRadiusPercent, gmMode, gmTorchlight) => {
        const tokenX = layout.offsetX + tokenPos.x * layout.scaledWidth;
        const tokenY = layout.offsetY + tokenPos.y * layout.scaledHeight;
        
        // Shadow
        ctx.fillStyle = CONFIG.COLORS.TOKEN_SHADOW;
        ctx.beginPath();
        ctx.arc(tokenX + CONFIG.TOKEN.SHADOW_OFFSET, tokenY + CONFIG.TOKEN.SHADOW_OFFSET, CONFIG.TOKEN.RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Token body
        ctx.fillStyle = CONFIG.COLORS.TOKEN_FILL;
        ctx.strokeStyle = CONFIG.COLORS.TOKEN_STROKE;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(tokenX, tokenY, CONFIG.TOKEN.RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Highlight
        ctx.fillStyle = CONFIG.COLORS.TOKEN_HIGHLIGHT;
        ctx.beginPath();
        ctx.arc(tokenX - CONFIG.TOKEN.HIGHLIGHT_OFFSET, tokenY - CONFIG.TOKEN.HIGHLIGHT_OFFSET, CONFIG.TOKEN.HIGHLIGHT_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Halo
        if (gmMode || gmTorchlight) {
          const haloRadius = (revealRadiusPercent / 100) * layout.scaledWidth;
          const gradient = ctx.createRadialGradient(tokenX, tokenY, 0, tokenX, tokenY, haloRadius);
          
          if (gmTorchlight) {
            gradient.addColorStop(0, `rgba(${CONFIG.COLORS.TORCH_HALO.r}, ${CONFIG.COLORS.TORCH_HALO.g}, ${CONFIG.COLORS.TORCH_HALO.b}, 0.75)`);
            gradient.addColorStop(1, `rgba(${CONFIG.COLORS.TORCH_HALO_OUTER.r}, ${CONFIG.COLORS.TORCH_HALO_OUTER.g}, ${CONFIG.COLORS.TORCH_HALO_OUTER.b}, 0.25)`);
          } else if (gmMode) {
            gradient.addColorStop(0, `rgba(${CONFIG.COLORS.GM_HALO.r}, ${CONFIG.COLORS.GM_HALO.g}, ${CONFIG.COLORS.GM_HALO.b}, 0.75)`);
            gradient.addColorStop(1, `rgba(${CONFIG.COLORS.GM_HALO.r}, ${CONFIG.COLORS.GM_HALO.g}, ${CONFIG.COLORS.GM_HALO.b}, 0.25)`);
          }

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(tokenX, tokenY, haloRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      };

      // WebSocket connection
      useEffect(() => {
        setIsTouchDevice('ontouchstart' in window || navigator.maxTouchPoints > 0);
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${window.location.host}`);
        wsRef.current = ws;

        ws.onopen = () => {
          console.log('Connected to server');
          setConnected(true);
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          
          switch(data.type) {
            case 'init':
              setIsGM(data.isGM);
              if (data.state.gmTorchlight !== undefined) {
                setGmTorchlight(data.state.gmTorchlight);
              }
              if (data.state.tokenPos) setTokenPos(data.state.tokenPos);
              if (data.state.exploredAreas) setExploredAreas(data.state.exploredAreas);
              if (data.state.revealRadiusPercent !== undefined) {
                setRevealRadiusPercent(data.state.revealRadiusPercent);
              }
              if (data.state.mapImage) {
                const img = new Image();
                img.onload = () => setMapImage(img);
                img.src = data.state.mapImage;
              }
              break;

            case 'update':
              isReceivingUpdate.current = true;
              setTokenPos(data.tokenPos);
              setExploredAreas(data.exploredAreas);
              setTimeout(() => {
                isReceivingUpdate.current = false;
              }, CONFIG.MOVEMENT.UPDATE_DEBOUNCE_MS);
              break;

            case 'radius':
              if (isReceivingUpdate.current) break;
              const incoming = Number(data.revealRadiusPercent);
              if (!isNaN(incoming) && isFinite(incoming)) {
                setRevealRadiusPercent(incoming);
              }
              break;

            case 'torchToggle':
              setGmTorchlight(Boolean(data.torchEnabled));
              break;

            case 'map':
              const img = new Image();
              img.onload = () => setMapImage(img);
              img.src = data.mapImage;
              break;

            case 'reset':
              setExploredAreas([]);
              setTokenPos(CONFIG.DEFAULTS.START_POS);
              setZoom(CONFIG.DEFAULTS.ZOOM);
              setPanOffset({ x: 0, y: 0 });
              break;
          }
        };

        ws.onclose = () => {
          console.log('Disconnected from server');
          setConnected(false);
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
        };

        return () => ws.close();
      }, []);

      // Set player default zoom (GM keeps 1x, players start at 3x)
      useEffect(() => {
        if (!connected) return;     // Don't fire before the socket handshake
        setZoom(isGM ? 1 : 3);      // GM = normal, player = 300%
      }, [connected, isGM]);

      // After zoom is applied and map is loaded, center viewport on token (players only)
      useEffect(() => {
        if (!connected) return;
        if (isGM) return;            // GM controls their own view
        if (!mapImage) return;
        if (zoom !== 3) return;      // Only fire when initial 300% zoom is active

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext("2d");

        // Force one layout computation so we know scaled sizes
        const layout = calculateCanvasLayout(canvas, mapImage, zoom, { x: 0, y: 0 });

        // Compute pixel position of token
        const tokenX = layout.offsetX + tokenPos.x * layout.scaledWidth;
        const tokenY = layout.offsetY + tokenPos.y * layout.scaledHeight;

        // Target center of screen
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Pan offset needed to bring token to center
        const newPan = {
          x: centerX - tokenX,
          y: centerY - tokenY,
        };

        setPanOffset(newPan);
      }, [connected, isGM, mapImage, zoom]);


      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              setMapImage(img);
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                wsRef.current.send(JSON.stringify({
                  type: 'map',
                  mapImage: event.target.result
                }));
              }
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
          setExploredAreas([]);
          setTokenPos(CONFIG.DEFAULTS.START_POS);
        }
      };

      const handleRadiusChange = (val) => {
        const pct = Number(val);
        if (!isNaN(pct)) {
          setRevealRadiusPercent(pct);
          isReceivingUpdate.current = true;

          if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.send(
              JSON.stringify({
                type: 'radius',
                revealRadiusPercent: pct
              })
            );
          }

          setTimeout(() => {
            isReceivingUpdate.current = false;
          }, CONFIG.MOVEMENT.UPDATE_DEBOUNCE_MS);
        }
      };

      const handleTorchToggle = (checked) => {
        setGmTorchlight(checked);
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(
            JSON.stringify({
              type: "torchToggle",
              torchEnabled: checked
            })
          );
        }
      };

      useEffect(() => {
        if (mapImage && !gmMode && !isReceivingUpdate.current) {
          const lastArea = exploredAreas[exploredAreas.length - 1];
          const needsNewEntry = !lastArea || 
            lastArea.x !== tokenPos.x || 
            lastArea.y !== tokenPos.y;
          
          if (needsNewEntry) {
            const newExplored = [...exploredAreas, tokenPos];
            setExploredAreas(newExplored);
            
            if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
              wsRef.current.send(JSON.stringify({
                type: 'move',
                tokenPos: tokenPos,
                exploredAreas: newExplored
              }));
            }
          }
        }
      }, [tokenPos, mapImage, gmMode]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (isReceivingUpdate.current) return;
          
          const step = CONFIG.MOVEMENT.STEP;
          setTokenPos(prev => {
            let newPos = { ...prev };
            
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
              newPos.y = Math.max(0, prev.y - step);
            } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
              newPos.y = Math.min(1, prev.y + step);
            } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
              newPos.x = Math.max(0, prev.x - step);
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
              newPos.x = Math.min(1, prev.x + step);
            } else {
              return prev;
            }
            
            return newPos;
          });
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      useEffect(() => {
        if (!mapImage) return;

        const canvas = canvasRef.current;
        const blurCanvas = blurCanvasRef.current;
        if (!canvas || !blurCanvas) return;

        const ctx = canvas.getContext('2d');
        const blurCtx = blurCanvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();

        // Match canvas size
        canvas.width = rect.width;
        canvas.height = rect.height;
        blurCanvas.width = rect.width;
        blurCanvas.height = rect.height;

        const layout = calculateCanvasLayout(canvas, mapImage, zoom, panOffset);

        // --- Draw main map ---
        drawClearMap(ctx, canvas, mapImage, layout);

        // --- Draw Fog of War / Blur for player view ---
        if (!gmMode) {
          blurCtx.clearRect(0, 0, blurCanvas.width, blurCanvas.height);
          blurCtx.fillStyle = CONFIG.CANVAS.BACKGROUND_COLOR;
          blurCtx.fillRect(0, 0, blurCanvas.width, blurCanvas.height);

          // Apply blur to map
          blurCtx.filter = `blur(${CONFIG.CANVAS.BLUR_AMOUNT}px)`;
          blurCtx.drawImage(mapImage, layout.offsetX, layout.offsetY, layout.scaledWidth, layout.scaledHeight);
          blurCtx.filter = 'none';

          // Apply darkness overlay if torchlight
          if (gmTorchlight) {
            blurCtx.fillStyle = `rgba(0, 0, 0, ${CONFIG.CANVAS.DARKNESS_OPACITY})`;
            blurCtx.fillRect(0, 0, blurCanvas.width, blurCanvas.height);
          }

          blurCtx.globalCompositeOperation = 'destination-out';

          const visionRadius = (revealRadiusPercent / 100) * layout.scaledWidth;

          if (gmTorchlight) {
            // Torch mode: reveal only current token
            const x = layout.offsetX + tokenPos.x * layout.scaledWidth;
            const y = layout.offsetY + tokenPos.y * layout.scaledHeight;
            drawVisionCircle(blurCtx, x, y, visionRadius);
          } else {
            // Normal player view: blur entire map except last token drop
            if (isDragging) {
              // While dragging: hide everything (full blur)
              // Do nothing here
            } else {
              // Reveal last token drop
              const last = exploredAreas[exploredAreas.length - 1];
              if (last) {
                const x = layout.offsetX + last.x * layout.scaledWidth;
                const y = layout.offsetY + last.y * layout.scaledHeight;
                drawVisionCircle(blurCtx, x, y, visionRadius);
              }
            }
          }

          blurCtx.globalCompositeOperation = 'source-over';
        } else {
          // GM mode: no blur
          blurCtx.clearRect(0, 0, blurCanvas.width, blurCanvas.height);
        }

        // --- Draw token on main canvas ---
        drawToken(ctx, tokenPos, layout, revealRadiusPercent, gmMode, gmTorchlight);

      }, [mapImage, tokenPos, exploredAreas, zoom, panOffset, revealRadiusPercent, gmMode, gmTorchlight, isDragging]);

      const resetExploration = () => {
        setExploredAreas([]);
        setTokenPos(CONFIG.DEFAULTS.START_POS);
        setZoom(CONFIG.DEFAULTS.ZOOM);
        setPanOffset({ x: 0, y: 0 });
        
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: 'reset' }));
        }
      };

      const handleMouseDown = (e) => {
        if (e.button === 0) {
          setIsPanning(true);
          setPanStart({ x: e.clientX - panOffset.x, y: e.clientY - panOffset.y });
        }
      };

      const handleMouseMove = (e) => {
        if(isDraggingToken.current) return;
        if (isPanning) {
          setPanOffset({
            x: e.clientX - panStart.x,
            y: e.clientY - panStart.y
          });
        }
      };

      const handleMouseUp = () => {
        setIsPanning(false);
      };

      // Mouse down on blurCanvas (or main canvas if you prefer)
      const handleTokenMouseDown = (e) => {
         if (!isGM) return;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scale = Math.min(canvas.width / mapImage.width, canvas.height / mapImage.height) * zoom;
        const offsetX = (canvas.width - mapImage.width * scale) / 2 + panOffset.x;
        const offsetY = (canvas.height - mapImage.height * scale) / 2 + panOffset.y;
        const tokenX = offsetX + tokenPos.x * mapImage.width * scale;
        const tokenY = offsetY + tokenPos.y * mapImage.height * scale;

        const dist = Math.hypot(e.clientX - rect.left - tokenX, e.clientY - rect.top - tokenY);
        if (dist <= CONFIG.TOKEN.RADIUS * 1.5) {
          isDraggingToken.current = true;
          setIsDragging(true); // << start full-map blur
          dragStartOffset.current = {
            x: tokenX - (e.clientX - rect.left),
            y: tokenY - (e.clientY - rect.top)
          };
          e.preventDefault();
        }
      };

      const handleTokenMouseMove = (e) => {
        updateDraggingToken(e);
      };

      // Update token position while dragging
      const updateDraggingToken = (e) => {
        if (!isDraggingToken.current) return;

        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        const scale = Math.min(canvas.width / mapImage.width, canvas.height / mapImage.height) * zoom;
        const offsetX = (canvas.width - mapImage.width * scale) / 2 + panOffset.x;
        const offsetY = (canvas.height - mapImage.height * scale) / 2 + panOffset.y;

        const x = (e.clientX - rect.left + dragStartOffset.current.x - offsetX) / (mapImage.width * scale);
        const y = (e.clientY - rect.top + dragStartOffset.current.y - offsetY) / (mapImage.height * scale);

        const newPos = { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };

        if(isGM) {
          setTokenPos(newPos);
        }

        // Update explored areas
        // setExploredAreas(prev => {
        //   // Only add if position is new (avoid duplicates)
        //   const last = prev[prev.length - 1];
        //   if (!last || last.x !== newPos.x || last.y !== newPos.y) {
        //     const updated = gmTorchlight ? [newPos] : [...prev, newPos];

        //     // Send WS update
        //     if (wsRef.current?.readyState === WebSocket.OPEN) {
        //       wsRef.current.send(JSON.stringify({
        //         type: 'move',
        //         tokenPos: newPos,
        //         exploredAreas: updated
        //       }));
        //     }

        //     return updated;
        //   }
        //   return prev;
        // });
      };


      const handleTokenMouseUp = () => {
        if (isDraggingToken.current) {
            isDraggingToken.current = false;
            setIsDragging(false);

            // Now commit the position to exploredAreas and notify players
            setExploredAreas(prev => {
                const updated = [...prev, tokenPos];

                if (wsRef.current?.readyState === WebSocket.OPEN) {
                    wsRef.current.send(JSON.stringify({
                        type: 'move',
                        tokenPos,
                        exploredAreas: updated
                    }));
                }

                return updated;
            });
        }
    };


      const isTouchPanning = useRef(false);
      const touchStartTimeout = useRef(null);
      const initialTouchCount = useRef(0);
      
      const handleTouchStart = (e) => {
        if (touchStartTimeout.current) {
          clearTimeout(touchStartTimeout.current);
          touchStartTimeout.current = null;
        }

        initialTouchCount.current = e.touches.length;

        if (e.touches.length >= 2) {
          e.preventDefault();
          isTouchPanning.current = true;
          setIsPanning(true);
          const touch = e.touches[0];
          setPanStart({ x: touch.clientX - panOffset.x, y: touch.clientY - panOffset.y });
        } else if (e.touches.length === 1) {
          const rect = e.target.getBoundingClientRect();
          const touch = e.touches[0];
          
          touchStartTimeout.current = setTimeout(() => {
            if (initialTouchCount.current === 1 && !isTouchPanning.current) {
              updateTokenFromTouch(touch, rect);
            }
            touchStartTimeout.current = null;
          }, CONFIG.MOVEMENT.TOUCH_DELAY_MS);
        }
      };

      const handleTouchMove = (e) => {
        e.preventDefault();
        
        if (e.touches.length >= 2) {
          if (touchStartTimeout.current) {
            clearTimeout(touchStartTimeout.current);
            touchStartTimeout.current = null;
          }
          isTouchPanning.current = true;
          setIsPanning(true);
        }
        
        if (e.touches.length >= 2 || isTouchPanning.current) {
          const touch = e.touches[0];
          setPanOffset({
            x: touch.clientX - panStart.x,
            y: touch.clientY - panStart.y
          });
        } else if (e.touches.length === 1 && !isTouchPanning.current && !touchStartTimeout.current) {
          const rect = e.target.getBoundingClientRect();
          const touch = e.touches[0];
          updateTokenFromTouch(touch, rect);
        }
      };

      const handleTouchEnd = (e) => {
        if (touchStartTimeout.current) {
          clearTimeout(touchStartTimeout.current);
          touchStartTimeout.current = null;
        }

        if (e.touches.length === 0) {
          isTouchPanning.current = false;
          setIsPanning(false);
          initialTouchCount.current = 0;
        }
      };

      const updateTokenFromTouch = (touch, rect) => {
        if (!mapImage || isReceivingUpdate.current || isPanning || isTouchPanning.current) return;
        
        const canvas = canvasRef.current;
        const scale = Math.min(canvas.width / mapImage.width, canvas.height / mapImage.height) * zoom;
        const scaledWidth = mapImage.width * scale;
        const scaledHeight = mapImage.height * scale;
        const offsetX = (canvas.width - scaledWidth) / 2 + panOffset.x;
        const offsetY = (canvas.height - scaledHeight) / 2 + panOffset.y;

        const x = (touch.clientX - rect.left - offsetX) / scaledWidth;
        const y = (touch.clientY - rect.top - offsetY) / scaledHeight;

        if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
          const newPos = { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
          setTokenPos(newPos);
        }
      };

      return (
        <div className="w-full h-screen bg-gray-900 flex flex-col">
          <div className="bg-gray-800 border-b border-gray-700 p-4">
            <div className="flex items-center justify-between gap-4 flex-wrap">
              <div className="flex items-center gap-4">
                <h1 className="text-2xl font-bold text-white">Fog of War VTT</h1>
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${connected ? 'bg-green-500' : 'bg-red-500'}`}></div>
                  <span className="text-sm text-gray-300">
                    {connected ? 'Connected' : 'Disconnected'}
                  </span>
                </div>
              </div>
              
              <div className="flex items-center gap-4 flex-wrap">
                {isGM && (
                  <label className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded cursor-pointer transition-colors">
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                    </svg>
                    <span>Upload Map</span>
                    <input type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                  </label>
                )}
  
                {isGM && (
                  <>
                    <label className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded cursor-pointer transition-colors">
                      <input 
                        type="checkbox" 
                        checked={gmMode}
                        onChange={(e) => setGmMode(e.target.checked)}
                        className="w-4 h-4"
                      />
                      <span>GM Mode (No Fog)</span>
                    </label>
                    
                    <div className="flex items-center gap-2">
                      <label className="text-gray-300 text-sm">Reveal Radius:</label>
                      <input 
                        type="range" 
                        min="1" 
                        max="25" 
                        value={revealRadiusPercent} 
                        onChange={(e) => handleRadiusChange(Number(e.target.value))}
                        className="w-32"
                      />
                      <span className="text-gray-300 text-sm min-w-[3rem] text-right">{revealRadiusPercent}%</span>
                    </div>

                    <label className="flex items-center gap-2 px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded cursor-pointer transition-colors">
                      <input 
                        type="checkbox" 
                        checked={gmTorchlight}
                        onChange={(e) => handleTorchToggle(e.target.checked)}
                        className="w-4 h-4"
                      />
                      <span>Show Torchlight Halo</span>
                    </label>
                  </>
                )}

                <div className="flex items-center gap-2">
                  <button 
                    onClick={() => setZoom(z => Math.max(0.5, z - 0.1))}
                    className="p-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
                    title="Zoom Out"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7" />
                    </svg>
                  </button>
                  <span className="text-gray-300 text-sm w-12 text-center">{Math.round(zoom * 100)}%</span>
                  <button 
                    onClick={() => setZoom(z => Math.min(4, z + 0.1))}
                    className="p-2 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors"
                    title="Zoom In"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7" />
                    </svg>
                  </button>
                </div>
                
                <button 
                  onClick={resetExploration}
                  className="flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded transition-colors"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                  <span>Reset</span>
                </button>
              </div>
            </div>
          </div>

          <div className="flex-1 relative overflow-hidden">
            <div className="relative w-full h-full">
              <canvas 
                ref={canvasRef} 
                className="absolute inset-0 w-full h-full"
              />
              <canvas 
                ref={blurCanvasRef}
                className="absolute inset-0 w-full h-full cursor-move"
                onMouseDown={(e) => { handleMouseDown(e); handleTokenMouseDown(e); }}
                onMouseMove={(e) => { handleMouseMove(e); handleTokenMouseMove(e); }}
                onMouseUp={(e) => { handleMouseUp(e); handleTokenMouseUp(e); }}
                onMouseLeave={(e) => { handleMouseUp(e); handleTokenMouseUp(e); }}
                onTouchStart={handleTouchStart}
                onTouchMove={handleTouchMove}
                onTouchEnd={handleTouchEnd}
                style={{ touchAction: 'none' }}
              />
            </div>
            
            {!mapImage && (
              <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                <div className="text-center text-gray-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                  </svg>
                  <p className="text-xl">Upload a map to begin</p>
                  <p className="text-sm mt-2">Use arrow keys or WASD to move the party token</p>
                </div>
              </div>
            )}
          </div>

          <div className="bg-gray-800 border-t border-gray-700 p-3">
            <div className="text-gray-300 text-sm text-center">
              <span className="font-semibold">Controls:</span> 
              {isTouchDevice 
                ? ' Tap to move token • Two-finger drag to pan' 
                : ' Arrow Keys or WASD to move • Left Click + Drag to pan'
              } • {gmMode ? 'GM Mode Active - Full map visible' : 'Fog of War Active'}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>