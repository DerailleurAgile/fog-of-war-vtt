<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fog of War VTT</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Phase 1: Utils -->
  <script type="module" src="/src/utils/config.js"></script>
  <script type="module" src="/src/utils/canvasHelpers.js"></script>

  <!-- Phase 2: Hooks -->
  <script src="/src/hooks/usePanZoom.js"></script>
  <script src="/src/hooks/useTokenMovement.js"></script>
  <script src="/src/hooks/useTokenDrag.js"></script>
  <script src="/src/hooks/useWebSocket.js"></script>

  <!-- Phase 3: Components (need Babel processing for JSX) -->
  <script type="text/babel" src="/src/components/Controls/Footer.jsx"></script>
  <script type="text/babel" src="/src/components/Controls/ZoomControls.jsx"></script>
  <script type="text/babel" src="/src/components/Controls/GMControls.jsx"></script>
  <script type="text/babel" src="/src/components/Controls/Header.jsx"></script>
  <script type="text/babel" src="/src/components/Canvas/GameCanvas.jsx"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function App() {
      // Use the hooks
      const canvasRef = useRef(null);
      const blurCanvasRef = useRef(null);
      const isReceivingUpdate = useRef(false);
      
      const [mapImage, setMapImage] = useState(null);
      const [tokenPos, setTokenPos] = useState(CONFIG.DEFAULTS.START_POS);
      const [revealRadiusPercent, setRevealRadiusPercent] = useState(CONFIG.DEFAULTS.REVEAL_RADIUS_PERCENT);
      const [exploredAreas, setExploredAreas] = useState([]);
      const [gmMode, setGmMode] = useState(false);
      const [isGM, setIsGM] = useState(false);
      const [gmTorchlight, setGmTorchlight] = useState(false);
      const [isTouchDevice, setIsTouchDevice] = useState(false);
      
      // Use pan/zoom hook
      const panZoom = usePanZoom(CONFIG.DEFAULTS.ZOOM);
      
      // Use WebSocket hook
      const { wsRef, connected, sendMessage } = useWebSocket(
        setIsGM,
        setGmTorchlight,
        setTokenPos,
        setExploredAreas,
        setRevealRadiusPercent,
        setMapImage,
        panZoom.setZoom,
        panZoom.setPanOffset,
        isReceivingUpdate
      );
      
      // Use keyboard movement
      useTokenMovement(tokenPos, setTokenPos, isReceivingUpdate);
      
      // Use token dragging (GM only)
      const tokenDrag = useTokenDrag(
        isGM,
        mapImage,
        tokenPos,
        setTokenPos,
        setExploredAreas,
        panZoom.zoom,
        panZoom.panOffset,
        wsRef
      );
      // calculateCanvasLayout ported to /src/utils/canvasHelpers.js
      // drawClearMap ported to /src/utils/canvasHelpers.js
      // drawVisionCircle ported to /src/utils/canvasHelpers.js
      // drawFogOfWar ported to /src/utils/canvasHelpers.js
      // drawToken ported to /src/utils/canvasHelpers.js
       // WebSocket connection ported to /src/hooks/useWebSocket.js
      
      // Initialize touch device detection
      useEffect(() => {
        setIsTouchDevice('ontouchstart' in window || navigator.maxTouchPoints > 0);
      }, []);

      // Set player default zoom (GM keeps 1x, players start at 3x)
      useEffect(() => {
        if (!connected) return;     // Don't fire before the socket handshake
        panZoom.setZoom(isGM ? 1 : 3);      // GM = normal, player = 300%
      }, [connected, isGM]);

      // After zoom is applied and map is loaded, center viewport on token (players only)
      useEffect(() => {
        if (!connected) return;
        if (isGM) return;            // GM controls their own view
        if (!mapImage) return;
        if (panZoom.zoom !== 3) return;      // Only fire when initial 300% zoom is active

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext("2d");

        // Force one layout computation so we know scaled sizes
        const layout = calculateCanvasLayout(canvas, mapImage, panZoom.zoom, { x: 0, y: 0 });

        // Compute pixel position of token
        const tokenX = layout.offsetX + tokenPos.x * layout.scaledWidth;
        const tokenY = layout.offsetY + tokenPos.y * layout.scaledHeight;

        // Target center of screen
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Pan offset needed to bring token to center
        const newPan = {
          x: centerX - tokenX,
          y: centerY - tokenY,
        };

        panZoom.setPanOffset(newPan);
      }, [connected, isGM, mapImage, panZoom.zoom]);


      const handleImageUpload = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
              setMapImage(img);
              if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                wsRef.current.send(JSON.stringify({
                  type: 'map',
                  mapImage: event.target.result
                }));
              }
            };
            img.src = event.target.result;
          };
          reader.readAsDataURL(file);
          setExploredAreas([]);
          setTokenPos(CONFIG.DEFAULTS.START_POS);
        }
      };

      const handleRadiusChange = (val) => {
        const pct = Number(val);
        if (!isNaN(pct)) {
          setRevealRadiusPercent(pct);
          isReceivingUpdate.current = true;

          if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.send(
              JSON.stringify({
                type: 'radius',
                revealRadiusPercent: pct
              })
            );
          }

          setTimeout(() => {
            isReceivingUpdate.current = false;
          }, CONFIG.MOVEMENT.UPDATE_DEBOUNCE_MS);
        }
      };

      const handleTorchToggle = (checked) => {
        setGmTorchlight(checked);
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(
            JSON.stringify({
              type: "torchToggle",
              torchEnabled: checked
            })
          );
        }
      };

      // Helper for single touch token movement
      const handleSingleTouch = (touch, rect) => {
        if (!mapImage || isReceivingUpdate.current || panZoom.isPanning) return;
        
        const canvas = canvasRef.current;
        const scale = Math.min(canvas.width / mapImage.width, canvas.height / mapImage.height) * panZoom.zoom;
        const scaledWidth = mapImage.width * scale;
        const scaledHeight = mapImage.height * scale;
        const offsetX = (canvas.width - scaledWidth) / 2 + panZoom.panOffset.x;
        const offsetY = (canvas.height - scaledHeight) / 2 + panZoom.panOffset.y;

        const x = (touch.clientX - rect.left - offsetX) / scaledWidth;
        const y = (touch.clientY - rect.top - offsetY) / scaledHeight;

        if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {
          const newPos = { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
          setTokenPos(newPos);
        }
      };

      // Automatically enable GM mode for authenticated GMs
      useEffect(() => {
        if (isGM && connected) {
          setGmMode(true);
        }
      }, [isGM, connected]);

      useEffect(() => {
        if (mapImage && !gmMode && !isReceivingUpdate.current) {
          const lastArea = exploredAreas[exploredAreas.length - 1];
          const needsNewEntry = !lastArea || 
            lastArea.x !== tokenPos.x || 
            lastArea.y !== tokenPos.y;
          
          if (needsNewEntry) {
            const newExplored = [...exploredAreas, tokenPos];
            setExploredAreas(newExplored);
            
            if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
              wsRef.current.send(JSON.stringify({
                type: 'move',
                tokenPos: tokenPos,
                exploredAreas: newExplored
              }));
            }
          }
        }
      }, [tokenPos, mapImage, gmMode]);

      // Reset exploration and token position to defaults
      const resetExploration = () => {
        setExploredAreas([]);
        panZoom.resetView();
        
        sendMessage({ type: 'reset' });
        // Don't set tokenPos here - wait for server response
      };
      
      return (
        <div className="w-full h-screen bg-gray-900 flex flex-col">
          <Header
            connected={connected}
            isGM={isGM}
            gmMode={gmMode}
            setGmMode={setGmMode}
            revealRadiusPercent={revealRadiusPercent}
            onRadiusChange={handleRadiusChange}
            gmTorchlight={gmTorchlight}
            onTorchToggle={handleTorchToggle}
            onImageUpload={handleImageUpload}
            zoom={panZoom.zoom}
            onZoomIn={panZoom.zoomIn}
            onZoomOut={panZoom.zoomOut}
            onReset={resetExploration}
          />
          
          <GameCanvas
            canvasRef={canvasRef}
            blurCanvasRef={blurCanvasRef}
            mapImage={mapImage}
            tokenPos={tokenPos}
            exploredAreas={exploredAreas}
            revealRadiusPercent={revealRadiusPercent}
            gmMode={gmMode}
            gmTorchlight={gmTorchlight}
            zoom={panZoom.zoom}
            panOffset={panZoom.panOffset}
            isDragging={tokenDrag.isDragging}
            onMouseDown={(e) => {
              const tokenWasClicked = tokenDrag.handleTokenMouseDown(e, canvasRef);
              if (!tokenWasClicked) {
                panZoom.handleMouseDown(e);
              }
            }}
            onMouseMove={(e) => {
              if (tokenDrag.isDragging) {
                tokenDrag.handleTokenMouseMove(e, canvasRef);
              } else {
                panZoom.handleMouseMove(e);
              }
            }}
            onMouseUp={(e) => {
              tokenDrag.handleTokenMouseUp();
              panZoom.handleMouseUp();
            }}
            onMouseLeave={(e) => {
              tokenDrag.handleTokenMouseUp();
              panZoom.handleMouseUp();
            }}
            onTouchStart={(e) => panZoom.handleTouchStart(e, handleSingleTouch)}
            onTouchMove={(e) => panZoom.handleTouchMove(e, handleSingleTouch)}
            onTouchEnd={panZoom.handleTouchEnd}
          />
          
          <Footer
            isTouchDevice={isTouchDevice}
            gmMode={gmMode}
          />
        </div>
      );
    }
    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>